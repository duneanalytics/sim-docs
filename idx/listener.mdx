---
title: Listener Contract
sidebarTitle: Listener
---

The core of a Sim IDX application is the **listener**, a Solidity contract that defines what onchain data to index.
By writing simple handlers for specific contract function calls or events, you instruct the Sim IDX framework on which data to capture and store in your database.

This guide covers the structure of a listener contract, how to add indexing for new functions, and how to test your logic.

## App Structure Explained

```text
my-idx-app/
├── sim.toml                       # App configuration
├── abis/                          # JSON ABIs for the contracts you want to index
├── apis/                          # Your TypeScript/Edge runtime APIs
└── listeners/                     #   ← a Foundry project
    ├── src/
    │   └── Main.sol               # PRIMARY editing target
    ├── test/
    │   └── Main.t.sol             # Unit tests for your listener
    └── lib/
        ├── sim-idx-sol/           # Core Sim IDX framework (DSL, context, helpers)
        └── sim-idx-generated/     # Code generated from the ABIs you add
```

### Primary Development Folders

The `apis/` and `listeners/` folders are the two folders you will work with most often.

### ABI Files

The `abis/` folder contains JSON ABI files of smart contracts you want to index.
The sample app includes `abis/UniswapV3Factory.json` for the Uniswap V3 Factory contract.

<Note>
If you want to add an additional ABI and learn what happens when you run the command, see the [`sim abi add` CLI command docs](/idx/cli#sim-abi-add-<file-path>).
</Note>

## Understanding the Listener Contract

Within `listeners/src/` you will find **`Main.sol`**, the primary Solidity file you will edit. When we refer to *the listener contract* we are talking about this file.

`Main.sol` defines two contracts:
1. **`Triggers`**: a lightweight contract that tells Sim IDX when to run your code.
2. **`Listener`**: the contract where you write the logic that runs when a trigger fires.

Let's break the file down step by step.

### Imports

```solidity
import "sim-idx-sol/Simidx.sol";
import "sim-idx-generated/Generated.sol";
```

These two imports pull in everything provided by the **Sim IDX framework**.

`Simidx.sol` provides the enums, structs, abstract contracts and helper functions you will use while writing your indexing logic.

`Generated.sol` contains the Solidity code created by the `sim abi add` command. For the sample app this file includes the Uniswap V3 Factory interface located at `listeners/lib/sim-idx-generated/UniswapV3Factory.sol`, which is generated automatically when you add that ABI.

### Triggers contract

A lightweight contract that tells Sim IDX when to run your code. Sim IDX does this through what we call a **trigger**. A trigger tells Sim IDX when to call one of your handlers for a function or event on an external contract.

```solidity
contract Triggers is BaseTriggers {
```

`BaseTriggers` comes from `Simidx.sol`. It is an abstract contract that provides helper functions, most importantly `addTrigger`.

```solidity
    function triggers() external override {
```

`BaseTriggers` requires you to implement the `triggers` function. Inside this function you register every trigger your application needs.

```solidity
        Listener listener = new Listener();
```

Here you create an instance of `Listener`, the second contract in `Main.sol`. We will look at this contract in the next section.

```solidity
        // Listen on Ethereum mainnet (chain 1) to Uniswap V3 Factory.createPool
        addTrigger(
            ChainIdContract(1, 0x1F98431c8aD98523631AE4a59f267346ea31F984),
            listener.triggerOnCreatePoolFunction()
        );
    }
}
```

`addTrigger` takes two arguments. The first argument identifies the on chain target by chain identifier and contract address. The second argument is the handler selector that the listener contract exposes.

Let's take a look at the Listener contract now.

### Listener contract

```solidity
contract Listener is UniswapV3Factory$OnCreatePoolFunction {
```

`Listener` extends `UniswapV3Factory$OnCreatePoolFunction`, an interface generated automatically by `sim abi add` and made available through `Generated.sol`.

After declaring the contract you define the events that you want to emit.

```solidity
    event PoolCreated(
        uint64  chainId,
        address caller,
        address pool,
        address token0,
        address token1,
        uint24  fee
    );
```

Emitting an event defines the shape of the database that Sim IDX creates. The event name becomes the table name and each parameter becomes a column.

Next you implement the handler that the generated interface expects.

```solidity
    function onCreatePoolFunction(
        FunctionContext                           memory ctx,
        UniswapV3Factory$createPoolFunctionInputs memory inputs,
        UniswapV3Factory$createPoolFunctionOutputs memory outputs
    ) external override {
        emit PoolCreated(
            uint64(block.chainid),
            ctx.txn.call.callee,
            outputs.pool,
            inputs.tokenA,
            inputs.tokenB,
            inputs.fee
        );
    }
}
```

Because you extended `UniswapV3Factory$OnCreatePoolFunction` you must implement `onCreatePoolFunction`.

Each handler name follows the pattern of the function or event it processes. When this handler runs Sim IDX gives you three arguments: a transaction context, the decoded inputs and the decoded outputs. You can use this data to emit one or more events which Sim IDX writes to your application database.

---

## Adding another ABI

1. Place the ABI JSON in `abis/` (e.g. `abis/MyContract.json`).
2. Run:

```bash
sim abi add abis/MyContract.json
```

The command regenerates `listeners/lib/sim-idx-generated/` and you can immediately write:

```solidity
import "sim-idx-generated/Generated.sol";

contract Listener is MyContract$OnSomeEvent, MyContract$OnSomeFunction {
    // ...
}
```

---

## Capturing more data

Need the block number? a log topic? manipulate multiple tables? Extend your event or emit additional ones.

```solidity
event PoolCreatedEx(
    uint64   chainId,
    address  caller,
    address  pool,
    address  token0,
    address  token1,
    uint24   fee,
    uint256  blockNumber       // new field
);

function onCreatePoolFunction(
    FunctionContext memory ctx,
    UniswapV3Factory$createPoolFunctionInputs  memory inputs,
    UniswapV3Factory$createPoolFunctionOutputs memory outputs
)
    external
    override
{
    emit PoolCreatedEx(
        uint64(block.chainid),
        ctx.txn.call.callee,
        outputs.pool,
        inputs.tokenA,
        inputs.tokenB,
        inputs.fee,
        block.number
    );
}
```

---

## Testing your listener

Because `listeners/` is a Foundry project you can write standard Forge tests in `listeners/test/`. Running

```bash
sim test            # delegates to `forge test`
```

will compile the listener, execute the tests, and surface any failures in the CLI just like in any other Solidity project.

---

## Next steps

* Add new ABIs and triggers to broaden the coverage of your application.
* Explore the generated helpers in `lib/sim-idx-generated/` to see every function/event you can hook into.
* Head over to [`idx/deployment.mdx`](./deployment.mdx) to learn how to ship your listener to production.
