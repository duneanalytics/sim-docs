---
title: "Sim idx Quickstart"
description: "Get started with Sim idx and deploy your first blockchain data API in minutes."
---

This guide will walk you through installing the CLI, initializing your first app, understanding its structure, and deploying your first blockchain data API.

## What is Sim idx?

Sim idx is a framework designed to radically simplify the process of indexing blockchain data.
You write simple Solidity "listener" contracts to specify what on-chain data you're interested in, and Sim idx automatically indexes that data and provides you with the tools to build custom APIs to query it.

## Install the Sim idx CLI

The Sim idx CLI is your primary tool for interacting with the framework.

<Steps>
<Step title="Download the CLI">
  Download [the latest release ](https://drive.google.com/drive/folders/137naBu5bFX-6stc8x9fTyggApnT3w9Xx) of Sim CLI for your platform.
</Step>

<Step title="Install Dependencies">
  Install the required dependencies:
  
  ```bash
  # Install Foundry (nightly version)
  curl -L https://foundry.paradigm.xyz | bash && foundryup --install nightly
  
  # Install solc-typed-ast
  npm install -g solc-typed-ast
  ```
  
  For the best development experience, also install [the Hardhat VSCode plugin](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity) for code completion when editing listeners.

  <Info>
Sim idx uses the nightly version of Foundry. We're working to simplify this setup process. If you have trouble getting this working on your current system, consider setting up an Ubuntu machine. We'll have a Docker container available soon to make this even easier.
</Info>

</Step>

<Step title="Extract and Setup">
  Extract the downloaded file and make it executable:
  
  ```bash
  # Extract the tar file (replace with your downloaded filename)
  tar -xvzf sim_v0.0.27_linux_amd64.tar.gz
  
  # Make it executable
  chmod +x ./sim
  
  # Move to system bin (optional - allows you to run 'sim' from anywhere)
  sudo mv ./sim /usr/bin/sim
  ```
  
  <Info>
  **Mac users**: You must run `xattr -d com.apple.quarantine ./sim` on the extracted executable before making it executable.
  </Info>
</Step>

<Step title="Verify Installation">
  Verify the CLI is working:
  ```bash
  sim --version
  ```
  
  You should see output similar to:
  
  ```
  sim  (984668 2025-06-02T15:34:14.000000000Z)
  ```
</Step>
</Steps>

## Initialize Your First App

Let's create your first Sim idx app. We'll start with the default USDC sample app, which indexes USDC token transfers on Ethereum.

```bash
mkdir my-first-idx-app
cd my-first-idx-app
sim init
```

This command creates a new directory `my-first-idx-app` and initializes a new pre-configured sample app.

## App Structure Overview

The initialized app has the following structure:

```
my-first-idx-app/
├── sim.toml                     # App configuration (app name, etc.)
├── abis/                        # Stores contract ABI files (JSON)
├── listeners/                   # Foundry app for your listener contracts
│   ├── src/
│   │   └── Listener.sol         # YOUR PRIMARY EDITING TARGET!
│   ├── test/
│   │   └── Listener.t.sol       # Unit tests for your listener
│   ├── lib/simidx/src/
│   │   ├── Dsl.sol              # Core Sim idx DSL for triggers
│   │   └── generated/           # Solidity interfaces auto-generated from ABIs
└── apis/                        # Your custom API code
```

The `abis/` and the `listeners/` folders are the two main folders you'll be working with directly.

`abis/` contains JSON ABI files of smart contracts you want to index.
The sample app includes `abis/Usdc.json` for the USDC contract.

The `listeners/`directory is a Foundry app where you'll spend most of your development time, specifically editing `src/Listener.sol` to define what onchain events to listen for and what data to extract.

The `lib/simidx/src/` directory contains core Sim idx libraries and auto-generated interfaces that you'll import in your listeners.
We'll explore these in detail in the next section.

The `apis/` directory is where you'll write custom TypeScript APIs to query your indexed data.
After deployment, Sim idx provides you with a database connection and hosts your API code.

## Edit Listener

The sample app is set up to index successful `transfer` function calls on the [USDC contract on Ethereum mainne](https://etherscan.io/token/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).

`Listener.sol` is a Solidity smart contract you write that specifies what onchain data you're interested in.
Let's examine the sample `Listener.sol` for USDC transfers:

### Importing Generated Interfaces

First, we import the generated interfaces and structs from the auto-generated `Usdc.sol` file:

The file `listeners/lib/simidx/src/generated/Usdc.sol` is auto-generated based on the `abis/Usdc.json` ABI.
The auto-generated files provide helpful building blocks for `Listener.sol` that you can import.

```typescript
import { ProbeDsl, ChainIdContract } from "simidx/Dsl.sol";
import {
    Usdc$function_OnPostTransfer, // Interface for the transfer function handler
    Usdc$function_transferInputs, // Struct for transfer inputs
    Usdc$function_transferOutputs, // Struct for transfer outputs
    Usdc$postTransferFunction     // Helper to get transfer function selector for hooks
} from "simidx/generated/Usdc.sol";
```

When you add an ABI, Sim idx automatically generates interfaces like `Usdc$function_OnPostTransfer` and structs like `Usdc$function_transferInputs` that provide type-safe access to function parameters.
This is why we recommend the [Hardhat VSCode plugin](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity).
It helps you find the correct functions automatically through code completion.

### Contract Definition

Next, we define our listener contract:

```typescript
contract UserProbe is Usdc$function_OnPostTransfer, ProbeDsl {
```

Your listener contract implements the generated interface (`Usdc$function_OnPostTransfer`) to handle USDC transfer calls, and inherits from `ProbeDsl` to use Sim idx's trigger definition helpers.

### Event Definition

We define an event for the data we want to index:

```typescript
// Define an event for the data you want to index.
// This event's fields will become columns in your queryable dataset.
event Transfer(address indexed to, uint256 value);
```

Events are crucial because they define the structure of data that will be indexed. When this event is emitted, Sim idx captures the `to` address and `value` amount, making them queryable through your custom API.

### Constructor (Setting Up Triggers)

The constructor is where we define our triggers:

```typescript
constructor() {
    // addHook connects a trigger to a handler.
    addHook(
        // Trigger 1: What contract & chain to listen on?
        ChainIdContract(
            1, // Chain ID (1 for Ethereum Mainnet)
            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // USDC Contract Address on Mainnet
        ),
        // Trigger 2: Which function on that contract?
        // Usdc$postTransferFunction() is a helper from generated/Usdc.sol
        // It specifies we want to trigger *after* the 'transfer' function executes.
        Usdc$postTransferFunction(),
        // Handler: Which function in *this* contract should be called?
        UserProbe.onPostTransfer.selector // The selector of our onPostTransfer handler
    );
}
```

A **Trigger** defines conditions that determine when a specific handler function should be invoked during EVM execution. The `addHook()` call sets up a trigger for successful `transfer` function calls on the USDC contract, specifying the chain, contract address, and which function to monitor.

### Handler Function

Finally, we implement the handler that processes the data:

```typescript
function onPostTransfer(
    Usdc$function_transferInputs memory inputs, // Decoded inputs of the USDC transfer call
    Usdc$function_transferOutputs memory outputs // Decoded outputs of the USDC transfer call
) external override {
    // outputs.outArg0 typically represents the 'success' boolean of a transfer.
    if (outputs.outArg0 == true) { // Check if the transfer was successful
        // Emit the data you want to save.
        // 'inputs.to' and 'inputs.value' come from the decoded transfer call.
        emit Transfer(inputs.to, inputs.value);
    }
}
```

A **Handler** is a Solidity function that is automatically invoked when the trigger conditions are met. It receives decoded input and output data from the matched transaction, allowing you to process this data and emit events containing the information you want to index.

## Index a New Function

Let's say you want to index `approve` calls on the USDC contract.

### Find Generated Components for `approve`

Open `listeners/lib/simidx/src/generated/Usdc.sol`. You'll find:
*   Interface: `Usdc$function_OnPostApprove`
*   Input struct: `Usdc$function_approveInputs` (containing `spender` and `value`)
*   Output struct: `Usdc$function_approveOutputs` (containing the success boolean)
*   Hook helper: `Usdc$postApproveFunction()`

### Modify `Listener.sol`

**Import new components:**
```typescript
import {
    // ... existing imports ...
    Usdc$function_OnPostApprove,      // New interface
    Usdc$function_approveInputs,      // New input struct
    Usdc$function_approveOutputs,     // New output struct
    Usdc$postApproveFunction          // New hook helper
} from "simidx/generated/Usdc.sol";
```

**Implement the new interface:**
```typescript
contract UserProbe is Usdc$function_OnPostTransfer, Usdc$function_OnPostApprove, ProbeDsl {
    // ...
}
```

**Define a new event for `approve` data:**
```typescript
event Approval(address indexed spender, uint256 value);
```

**Add a new hook in the constructor:**
```typescript
constructor() {
    // ... existing hook for transfer ...

    addHook(
        ChainIdContract(1, 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), // Same USDC contract
        Usdc$postApproveFunction(),                                 // Trigger on 'approve'
        UserProbe.onPostApprove.selector                            // Call our new handler
    );
}
```

**Implement the new handler function:**
```typescript
function onPostApprove(
    Usdc$function_approveInputs memory inputs,
    Usdc$function_approveOutputs memory outputs
) external override {
    if (outputs.outArg0 == true) { // Check if approve was successful
        // Emit Approval data
        emit Approval(inputs.spender, inputs.value);
    }
}
```

## Build, Test, and Deploy

After making changes to `Listener.sol`, you're ready to compile your app, test it, and deploy it to the Sim idx platform.

<Steps>
<Step title="Build Your App">
Compile your Solidity contracts:
```bash
sim build
```
When successful, you'll see: `✓ Build completed successfully`
</Step>

<Step title="Test Your Listener">
Run your Solidity tests:
```bash
sim test
```
The sample app includes tests in `listeners/test/Listener.t.sol` that you can run and modify. When successful, you'll see: `✓ All tests passed successfully`
</Step>

<Step title="Authenticate">
Before deploying, authenticate with your API key. You can find your API key in the Sim portal:
```bash
sim authenticate
```
This will prompt you to paste your API key and save it locally.
</Step>

<Step title="Deploy Your Application">
Deploy your listener to start indexing:
```bash
sim deploy
```
</Step>
</Steps>

After successful deployment, you'll receive two key pieces of information in the CLI:

1. **API URL** - Where your custom API will be hosted:
```
api_url: "https://your-app.idx.dev.dune.com"
```

2. **Database Connection String** - PostgreSQL connection to your indexed data:

```
db_read_connection: "postgres://username:password@host/database?sslmode=require"
```

<Note>
Copy this connection string - you'll need it to connect your API to the indexed data.
</Note>

Your app will begin indexing blockchain events according to your defined triggers, and you can now build custom APIs to query this data.

## Inspect Your Data

Before building custom APIs, you can inspect your indexed data directly using any PostgreSQL client. Use the database connection string from your deployment to connect and explore:

```bash
# Using psql
psql "your_connection_string_here"

# List all tables
\dt

# Describe a table structure
\d "Transfer"

# View sample data
SELECT * FROM "Transfer" LIMIT 5;
```

The database tables are automatically created based on the events you define in your `Listener.sol`:
- **Transfer event** → `Transfer` table with columns: `to`, `value`, `block_number`, `log_index`, `transaction_hash`
- **Approval event** → `Approval` table with columns: `spender`, `value`, `block_number`, `log_index`, `transaction_hash`

<Info>
  You can connect to this database using any PostgreSQL client like psql, DBeaver, or Beekeeper Studio to explore the schema and test queries during development.
</Info>

## Build Your API

What Sim idx handles is deploying your API. 
What you'll do is write TypeScript code, using any NPM libraries to build your backend APIs.
You'll build a TypeScript-based backend, and you're going to read data from the database to query the data for your API.

### Understanding the APIs Folder

The `apis/` folder in your Sim idx app contains a **Cloudflare Workers** app that serves as your custom API layer. This is where you'll build endpoints to query the data that your listeners have indexed.

```
apis/
├── src/
│   ├── index.ts          # YOUR MAIN API FILE - Edit this!
│   └── types.ts          # Type definitions - Edit this!
├── package.json          # Dependencies and scripts
├── wrangler.jsonc        # Cloudflare Workers configuration
├── tsconfig.json         # TypeScript configuration
```

The APIs folder uses Cloudflare Workers for serverless deployment, providing global edge distribution and auto-scaling. Sim idx handles the deployment process - you just write the TypeScript code and run `sim deploy`.

**Files you should edit:**

- **`src/index.ts`** - Your main API implementation where you'll define endpoints and database connections
- **`src/types.ts`** - Custom type definitions and validation schemas
- **`package.json`** - Add new npm packages you need

### Setting Up Your API with Express.js

Navigate to the `apis/` directory in your project.
This is where you'll build your custom API endpoints.
While you can build your APIs in any way you like, we'll use Express.js for this example.

```bash
cd apis
npm install express pg dotenv
npm install --save-dev @types/express @types/pg
```

Create a `.env` file to store your database connection:

```env
DATABASE_URL=your_database_connection_string_from_sim_deploy
PORT=3000
```

<Warning>
  **Security**: Never commit your `.env` file to version control. Add it to your `.gitignore` file.
</Warning>

Now let's set up the basic Express.js server. Start by adding the imports and database connection in `src/index.ts`:

```typescript
import express from 'express';
import { Pool } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

// Database connection - use the connection string from sim deploy
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

app.use(express.json());
```

This sets up Express.js and creates a PostgreSQL connection pool using the database connection string you received from `sim deploy`.
Make sure to replace `DATABASE_URL` in the `.env` file with your actual connection string.

### Setting Up API Endpoints for Transfers

Add an endpoint to query transfer data:

```typescript
// Get all transfers
app.get('/api/transfers', async (req, res) => {
  try {
    const query = 'SELECT * FROM "Transfer" ORDER BY block_number DESC LIMIT 100';
    const result = await pool.query(query);
    
    res.json({
      data: result.rows,
      count: result.rows.length
    });
  } catch (error) {
    console.error('Error fetching transfers:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

This endpoint queries the `Transfer` table (created from your Transfer event) and returns the most recent 100 transfers. You have full access to the database, so you can structure your API however you want. For example, if you want to return transfers by recipient, you could create a URL like `/api/transfers/:address` and filter by the `to` field.

**Example API Response for `/api/transfers`:**
```json
{
  "data": [
    {
      "to": "0x8ce8725A65DaE7d3D5543372D5415f4F8ad448f9",
      "value": "1000000",
      "block_number": 18500000,
      "log_index": 45,
      "transaction_hash": "0x1234..."
    }
  ],
  "count": 1
}
```

### Setting Up API Endpoints for Approvals

Add an endpoint to query approval data:

```typescript
// Get all approvals
app.get('/api/approvals', async (req, res) => {
  try {
    const query = 'SELECT * FROM "Approval" ORDER BY block_number DESC LIMIT 100';
    const result = await pool.query(query);
    
    res.json({
      data: result.rows,
      count: result.rows.length
    });
  } catch (error) {
    console.error('Error fetching approvals:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Start the server
app.listen(port, () => {
  console.log(`API server running on port ${port}`);
});
```

This endpoint queries the `Approval` table (created from your Approval event) and returns the most recent 100 approvals. You can customize these endpoints to add filtering, pagination, or any other functionality your application needs.

**Example API Response for `/api/approvals`:**
```json
{
  "data": [
    {
      "spender": "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
      "value": "1000000000",
      "block_number": 18500001,
      "log_index": 12,
      "transaction_hash": "0x5678..."
    }
  ],
  "count": 1
}
```

### Test Your API

Once you've set up your API, you can test it locally:

```bash
npm run dev
```

Your API will be available at `http://localhost:3000`. You can test the endpoints by visiting:
- `http://localhost:3000/api/transfers`
- `http://localhost:3000/api/approvals`

### Deployment

After you have your APIs written and tested properly, you can deploy them by running:

```bash
sim deploy
```

This will deploy your API code and make it available at your API URL.
Sim idx handles the entire deployment process for you.

## Next Steps

Congratulations! You've now seen the basics of creating, testing, and deploying a Sim idx application.

Happy indexing! If you have questions or feedback during this private beta, please reach out through the provided channels.